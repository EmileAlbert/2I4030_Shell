\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\usepackage{PersonalPackage}
\usepackage{hyperref}

\usepackage{titling}
\def\@subtitle{no title}
\newcommand{\subtitle}[1]{\def\@subtitle{#1}}

\title{Laboratoire de système d'exploitation}
\subtitle{Création d'un shell}

\author{
ALBERT Emile 14022@ecam.be\\\\
HAGOPIAN Armen 14040@ecam.be\\\\
SELLESLAGH Tom 14164@ecam.be\\\\
}

\begin{document}
%\begin{titlepage} 
%	\hspace{0.5cm}	
%	\rule{1.5pt}{\textheight} 
%	\hspace{1.5cm}		
%	\parbox[b]{13cm}
%	{  		
%		{\huge \thetitle}\\[1\baselineskip]
%		{\LARGE \@subtitle} \\[1\baselineskip]
%		\today \\[3\baselineskip]
%		
%		{\Large \theauthor}\\[22\baselineskip]
%		\hspace*{6cm}\includegraphics[scale=0.3]{logo_ECAM.png}
%	}
%\end{titlepage}

\section{Introduction}
Les objectifs de ce laboratoire étaient de penser et d'implémenter un shell. Notre groupe étant composé de trois électroniciens, tout trois participant au projet Eurobot, nous avons décidé de profité de ce laboratoire pour créer une interface système permettant nous permettant de monitorer les tests sur un robot commandé par une raspberry pi.\\
  
Le but de ce shell est donc de pouvoir observer lors de l'exécution d'un test de commande moteur sur la raspberry, un maximum d'information intéressante sur l'état du contrôleur. L'interface système devient alors une aide au debuging des programmes s'exécutant sur la raspberry.

\section{Implémentation}
\subsection{L'environnement du shell}
La structure du shell tel que nous l'avons utilisée dans ce projet a été repris du code crée par Stephen Brennan sur son compte Github : \url{https://github.com/brenns10/lsh}\\

La structure du shell peut être vue en plusieurs sections :
\begin{itemize}
\item La déclaration des fonctions de l'interface, des pointeurs vers ces fonctions et des noms d'appel
\item L'implémentation des fonctionnalités
\item Le c\oe{}ur du shell 
\end{itemize}

\subsubsection{Déclaration des fonctions de l'interface, des pointeurs et des noms d'appel}
Dans cette partie de configuration, il s'agit de déclarer les variables associées aux fonctions utilisées dans le programme ainsi que leur pointeur.\\

De plus, on définis les noms d'appel des fonctions. Ces nom correspondent aux chaine de caractère utilisée par l'utilisateur pour invoquer telle ou telle fonction.

\subsubsection{Implémentation des fonctions}
Cette partie regroupe l'ensemble des fonctions appelée lors d'une commande utilisateur. Les fonctions propres à notre projet sont donc codée dans cette section ainsi que les commandes propres au shell (\texttt{help, clear, exit})

\subsubsection{Coeur du shell}
Enfin, la dernière partie de la structure est composée des 6 fonctions requises au bon fonctionnement du shell. Ces 6 fonctions sont : 
\begin{itemize}
\item \texttt{rpi\_launch} - Lancement du shell\\
Fork du programme principal et gestion des enfants crée

\item \texttt{rpi\_execute} - Exécution des fonctions\\
Cette section lance les fonctions correspondantes au l'entrée de l'utilisateur

\item \texttt{rpi\_read\_line} - Lecture des commandes user\\
Fonction récupérant la chaine de caractère entrée par l'utilisateur

\item \texttt{rpi\_split\_line} - Décryptage des commandes user\\
Fonction servant à décrypter et à conditionner les entrées de l'utilisateur pour que ses commandes soient comprise

\item \texttt{rpi\_loop} - Super loop d'exécution\\
C'est la partie principale du programme qui appelle les fonctions nécessaires au shell en boucle

\item \texttt{main} - Fonction principal du programme\\
Script qui lance la boucle et donc le shell 
\end{itemize}

\subsection{Les commandes implémentées}
\subsubsection{\texttt{rpi\_raspInfo} invoqué avec \texttt{rasp}}
La commande \texttt{rasp} permet de récupérer des informations sur le hardware de la raspberry. Ces données peuvent être utiles tant pour le \textit{debuging} que pour l'optimisation des performances d'un programme.\\

La fonction prend obligatoirement en paramètre l'information désirée. Les différentes informations disponible dans la fonctions sont les suivantes :

\begin{itemize}
\item \texttt{rasp -t [PARAM]} permet de récupérer la température du processeur\\

La commande prend obligatoirement en paramètre l'unité dans laquelle on veut récupérer la température : 
\begin{itemize}
\item \texttt{rasp -t cel} - Température en degré Celsius
\item \texttt{rasp -t far} - Température en degré Farenheit
\item \texttt{rasp -t kel} - Température en degré Kelvin
\end{itemize}

\item \texttt{rasp -cpu} permet de récupérer le pourcentage d'utilisation du CPU au temps t et de façon statique

\item \texttt{rasp -ram} permet de connaitre le pourcentage d'utilisation de la mémoire RAM au temps t et de façon statique
\end{itemize}

\subsubsection{\texttt{rpi\_pigpiod\_status} invoqué avec \texttt{pigpio}}

\subsection{Appels systèmes utilisés}
\subsubsection{\texttt{fork}}
Cet appel système est utilisé dans le script du shell pour créer un processus enfant gérant la commande et l'exécution de la fonctions demandée. 

\subsubsection{\texttt{open}}
Cet appel est utilisé dans la fonction \texttt{rasp} et plus précisément pour récupérer la valeur de la température inscrite plus tôt dans un ficher texte. 

\subsubsection{\texttt{exit}}


\textcolor{red}{
\subsection{Script de compilation}
La compilation du code source écrit en C s'effectue sur la raspberry même. La commande \url{gcc} permet de créer un fichier ELF, exécutable sur le contrôleur. 
}

\textcolor{red}{\section{Discussion}}
\subsection*{Un interpréteur de commandes peut exécuter les commandes lui-même ou déléguer cette exécution à d'autres exécutables. Quels sont les avantages et inconvénients de ces deux possibilités ?}

\textbf{Exécution par l'interpréteur de commande\\}
\textbf{Délégation à un autre exécutable\\}


\subsection*{Pour interagir avec le hardware et le système d'exploitation, on peut utiliser un appel système, une  fonction  de  la  librairie  standard  C  ou  passer  par  un  programme  système.  Quels  sont  les avantages et inconvénients de ces trois possibilités ?}

\textbf{Appel système\\}
\begin{itemize}
\item Lenteur 
\item Implémenté dans le noyau Linux 
\item Priorité par rapport à d'autre tâche 
\end{itemize}

\textbf{Fonction de la librairie standart C\\}
\begin{itemize}
\item Bibliothèque extérieur au programme
\item Frein à l'exportation - pas la standard 
\item Souvent une intermédiaire entre l'user et les appels système - plus facile à utiliser 
\end{itemize}

\textbf{Programme système\\}
\begin{itemize}
\item Plus rapides que les appels systèmes 
\end{itemize}

\section{Sources}
\url{https://www.quora.com/What-is-the-difference-between-system-programs-and-system-calls-and-API}
\url{https://fr.wikibooks.org/wiki/Les_systèmes_d\%27exploitation/Le_noyau_d\%27un_système_d\%27exploitation}
\url{https://sites.uclouvain.be/SystInfo/notes/Theorie/html/Threads/processus.html}
\end{document}